#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "replytimeout.h"
#include "sendfiles.h"
#include <QFileDialog>
#include <QDebug>
#include <QStringList>
#include <QProcess>
#include <QMessageBox>
#include <QDialog>
#include <QDateTime>
#include <QUrlQuery>
#include <QNetworkRequest>
#include <QNetworkReply>
#include <QFileInfoList>
#include <QFileInfo>
#include <memory>
#include <QTimer>
#include <QJsonObject>
#include <QJsonDocument>



MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow),
    num(5)
{
    ui->setupUi(this);
    manager=new QNetworkAccessManager(this);

}

MainWindow::~MainWindow()
{
    delete ui;
    delete manager;
}

void MainWindow::on_inputButton_clicked()
{
    QString filePath = QFileDialog::getExistingDirectory(this, tr("Open Image"), "../",
                                                         QFileDialog::ShowDirsOnly
                                                         | QFileDialog::DontResolveSymlinks);
    input_path=filePath;
    ui->inputFilePath->setText(filePath);
    QDir dir(filePath);

    QStringList filters;
    filters << "*.png" << "*.jpg" << "*.bmp";
    QStringList list=dir.entryList(filters);
    ui->imageList->clear();
    ui->imageList->addItems(list);
    QFileInfoList absoluteList=dir.entryInfoList(filters);
    fileList.clear();
    for(int i=0;i<absoluteList.size();i++){
        fileList.append(absoluteList.at(i).filePath());
    }
}

void MainWindow::runDocker()
{
    QUrlQuery params;
    params.addQueryItem("folder", batchName);
    QUrl url("http://192.168.188.10:9000/docker?"+params.query());
    QNetworkRequest request(url);
    auto reply=manager->get(request);
    connect(reply,QNetworkReply::finished,
            [=](){
            reply->deleteLater();
            QMessageBox::information(this,"提示","start run docker",QMessageBox::Ok);
            get_progress();
    });

}

void MainWindow::get_resultFiles(){
    QString path =input_path+"/1.zip";
    QDir dir(input_path);
    if(!dir.exists(path))
    {
        dir.mkpath(input_path);
        qDebug()<<"directory now exists";

    }
    auto file = std::make_shared<QFile>(path);
    //QFile *file1=new QFile(path);
    file->open(QIODevice::ReadWrite);
    QUrl url("http://192.168.188.10:9000/orthomap");
    QNetworkRequest request(url);
    auto reply=manager->get(request);
    connect(reply, QNetworkReply::readyRead,
            [=](){
        std::vector<char> buffer(4096);
        qint64 bytesRead;
        while ((bytesRead=reply->read(&buffer[0],buffer.size()))>0){
            file->write(&buffer[0],bytesRead);
        }

    });
    connect(reply, QNetworkReply::finished,
            [=](){
        file->close();
        reply->deleteLater();
        QMessageBox::information(this,"提示","后台文件返回成功",QMessageBox::Ok);
    });

}

void MainWindow::get_progress(){
    QTimer *timer = new QTimer(this);
    connect(timer,QTimer::timeout,[=](){
        QUrl url("http://192.168.188.10:9000/progress");
        QNetworkRequest request(url);
        auto reply=manager->get(request);
        connect(reply,QNetworkReply::finished,[=](){
//            auto code = reply->error();
//            if(code != QNetworkReply::NoError) {
//                qDebug()<< "error: " << code;
//                qDebug()<<reply->errorString();
//                qDebug()<<reply->attribute( QNetworkRequest::HttpStatusCodeAttribute).toInt();
//                QByteArray ba=reply->readAll();
//                QString s_data = QString::fromUtf8(ba.data());
//                QJsonObject obj;
//                QJsonDocument doc = QJsonDocument::fromJson(s_data.toUtf8());
//                if(!doc.isNull()&&doc.isObject())
//                {
//                    obj = doc.object();
//                    QString title=obj.value("title").toString();
//                    QString description=obj.value("description").toString();
//                    QMessageBox::information(this,title,description,QMessageBox::Ok);
//                }
//                reply->abort();
//            }else{

                QByteArray ba=reply->readAll();
                QString s_data = QString::fromUtf8(ba.data());
                s_data=s_data.replace("\u001B[94m","");
                s_data=s_data.replace("\u001B[92m","");
                s_data=s_data.replace("\u001B[0m","");
                s_data=s_data.replace("\u001B[0;m","");
                QStringList list_data=s_data.split(QRegExp("\n|\r\n|\r"),QString::SkipEmptyParts);
                if(list_data.indexOf("[WARNING] Initial residual too low: 0 < 0.000001")>=0){
                    QMessageBox::information(this,"提示","图片量太少，请重新选择图片",QMessageBox::Ok);
                    reply->abort();
                    timer->stop();
                }else {
                    if(s_data!=""){
                    qDebug()<<s_data;
                    QString temp = QString::fromUtf8("running PYTHONPATH");
                    if(s_data.contains(temp)){
                        int progress=ui->progressBar->value();
                        qDebug()<<progress;
                        progress+=10;
                        ui->progressBar->setValue(progress);
                        int after=ui->progressBar->value();
                        qDebug()<<after;
                    }
                    if (list_data.indexOf("OpenDroneMap app finished")>=0){
                        qDebug()<<"OpenDroneMap app finished";
                        timer->stop();
                        timer->deleteLater();
                        reply->deleteLater();
                        ui->progressBar->setValue(110);
                        QMessageBox::information(this,"提示","finished",QMessageBox::Ok);
                        //文件夹生成了，从后台传回
                        get_resultFiles();
                    }
                }
                }
                reply->deleteLater();
//            }

        });
        connect(reply,static_cast<void (QNetworkReply::*)(QNetworkReply::NetworkError)>(&QNetworkReply::error),[](QNetworkReply::NetworkError code){
            qDebug()<<"error:"<<code;

        });
    });
    timer->start(2000); // 每隔2s
}
void MainWindow::stopDocker(){
    QUrlQuery params;
    params.addQueryItem("folder", batchName);
    QUrl url("http://192.168.188.10:9000/stopdocker?"+params.query());
    QNetworkRequest request(url);
    auto reply=manager->get(request);
    connect(reply,QNetworkReply::finished,[=](){
        QByteArray ba=reply->readAll();
        QString s_data = QString::fromUtf8(ba.data());
        //QMessageBox::information(this,"提示",s_data,QMessageBox::Ok);
        reply->deleteLater();

    });
}
void MainWindow::httpConnectTest(){
    QUrl url("http://192.168.188.10:9000/httpTest");
    QNetworkRequest request(url);
    auto reply=manager->get(request);
    connect(reply,QNetworkReply::finished,[=](){
        QNetworkReply::NetworkError code=reply->error();
        if(code==QNetworkReply::ConnectionRefusedError){
            QMessageBox::information(this,"提示","服务器链接不成功，请检查服务器状态",QMessageBox::Ok);
            reply->abort();
        }else
        {
            //如果之前有正在运行的docker，停掉，运行新的docker
            stopDocker();
            SendFiles files(fileList, batchName);
            //向服务器发送传输文件
            files.send(manager);
            //运行docker请求
            runDocker();

        }
        reply->deleteLater();

    });
}

void MainWindow::on_startButton_clicked()
{
    QString address=ui->lineEdit->text();
    QDateTime current_date_time =QDateTime::currentDateTime();
    QString current_date =current_date_time.toString("yyyy.MM.dd");
    batchName=address+"-"+current_date;
    ui->progressBar->setMinimum(0);
    ui->progressBar->setMaximum(110);
    ui->progressBar->setValue(0);
    httpConnectTest();


}

